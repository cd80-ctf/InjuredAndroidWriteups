# Flag 6 | Login 3
Welcome to the big leagues. No more surveys of basic Android app concepts; it's time for our first "classic" CTF challenge.

This challenge can be solved with either static or dynamic analysis, both of them equally useful. I'll give a walkthrough of both methods.

## The target

Launching the InjuredAndroid app and selecting the sixth flag, we find an old friend:

![home_screen](https://user-images.githubusercontent.com/86139991/173941568-f7697b11-df71-42dc-90a1-b2a02615b633.PNG)

Our goal is to find the password that unlocks the flag.

## First steps

### Reading the manifest

Searching `AndroidManifest.xml` for `"flag_six"` gives us the class `b3nac.injuredandroid.FlagSixLoginActivity`:

![manifest](https://user-images.githubusercontent.com/86139991/173941655-5ab4f7da-59a1-438b-b3f2-500ec166f77f.PNG)

Checking this class in the decompiler, we find another `submitFlag` function:

![submit_flag](https://user-images.githubusercontent.com/86139991/173941784-ba98a767-7bfb-4ba1-87f4-b46adec2c496.PNG)

Something old, something new. As before, our input string is being compared to a computed value. The comparison value is generated by calling `k.a()` on
what appears to be a base64 encoded string. So, what's `k.a()` doing?

### Finding the decryptor

As before, we can find the `k` class inside `b3nac.injuredandroid`:

![k_class](https://user-images.githubusercontent.com/86139991/173942038-f73c6f57-1d03-471c-a1c6-9fb1bc01ca33.PNG)

This seems to be a decryptor of some sort. Our function of interest, `a()`, takes a base64-encoded string, decodes it, then decrypts it with DES and returns
the decrypted value. The fact that DES is the encryption algorithm is worth noting. DES is known to be insecure on modern computers, as it key is only 56
bits. Any value encrypted with DES can be cracked in just over a day, so if you ever see DES being used in the real world, it should be a strong red flag.

Here is where the paths split. We can either analyze this app *statically* to find a quick way to break the encryption, or *dynamically* hook the decryption
function and extract the comparison value. Which you choose is a matter of taste, but it is useful to have both tools in your hacking toolbox, so new readers
are advised to follow both solutions.

## Static Analysis

Static analysis is analyzing an application without running it. This is usually done by looking at the disassembled (or decompiled) source code.
In this sense, all analysis we've done so far has been static analysis. The goal of our static analysis for this program is fairly simple:
figure out how the comparison value is decrypted and do it ourselves. Of course, since DES sucks, we could brute-force it, but there is a much easier
solution available.

### Finding the decryption key

First things first, let's see if we can find the key that the value is decrypted with. Some Googling reveals that the key is the value being passed to
`DESKeySpec` in the code, which happens in the line

```
SecretKey generateSecret = SecretKeyFactory.getInstance("DES").generateSecret(new DESKeySpec(f1472a));

```

We can check that `f1472a` is a class property defined to be equal to `h.b()`. From the decompiler, we see that `h` is another class implemented by
`b3nac.injuredandroid`. Let's look at the decompiled source:

![h_class](https://user-images.githubusercontent.com/86139991/173945103-8865505e-3485-4b09-a179-93e2e9f8ba05.PNG)

Well, that was easy. The function that provides the key (`h.b()`) simply returns `f1749a`, which is the base64-decoded value of `"Q2FwdHVyM1RoMXM="`.

### Decrypting the string

We could throw this string into an online decoder like we did before, but it won't do us much good -- we still need to use it to decrypt the input.
To do this, we'll introduce another key tey in any hacker's toolbelt -- Python scripting.

With a little Googling, we can throw together a Python script that decrypts the value passed in `FlagSixLoginActivity` with the base64-decoded key
(note that the package `pycryptodome` must be installed for this code to run:

```python
import base64

from Crypto.Cipher import DES

ENCODED_KEY = "Q2FwdHVyM1RoMXM="
ENCODED_STRING = "k3FElEG9lnoWbOateGhj5pX6QsXRNJKh///8Jxi8KXW7iDpk2xRxhQ=="

def decrypt():
    key_byte_array = base64.b64decode(ENCODED_KEY)[:8]
    string_byte_array = base64.b64decode(ENCODED_STRING)
    des_handler = DES.new(key_byte_array, DES.MODE_ECB)

    print(des_handler.decrypt(string_byte_array))

if __name__ == '__main__':
    decrypt()
```

Note that we trimmed the key to its first `8` characters, since DES keys are only `8` bytes long. Running this script gives us a nice readable string:

```
b"{This_Isn't_Where_I_Parked_My_Car}\x06\x06\x06\x06\x06\x06"
```

I'm still not sure what the `\x06`s are doing here, but plugging the readable part into the app gives us what we want:

![success_static](https://user-images.githubusercontent.com/86139991/173954178-bd4e341a-8e1b-49d2-8b23-673964107f3f.PNG)

Another win for static analysis. Now let's do it the fun way!

## Dynamic analysis

Contrary to static analysis, dynamic analysis involves debugging the program while it's actually running. In our case, the *de facto* runtime debugger
for Android is [Frida](https://frida.re/). It takes a bit of setting up, but once that's done, it is an *incredibly* powerful tool for analyzing
and attacking Android applications. Let's get started, shall we?

### Setting up Frida

Setting up Frida is a slightly involved process. First, we need to ensure our VM has enough room for the server, and that `adb` is running as root.
If you've followed the setup instructions in the README, this should already be done. If you haven't, you'll need to shut down your VM and follow
the instructions given there.

Once you've done that, go ahead and download and unzip the latest Android x86_64 Frida server from  [the Releases page](https://github.com/frida/frida/releases).

This is the server component of the Frida debugger. It'll run on our emulated phone and attach to processes we want to analyze. We'll use ADB to get it
on the phone:

1. Open a terminal in the directory with your unzipped debugger binary.
2. Rename the binary to `frida_server` (optional, but convenient).
3. Upload the binary to the emulated phone: `adb push frida_server /data/local/tmp`
4. Make the binary executable: `adb shell "chmod +x /data/local/tmp/frida_server"`
5. Run the Frida server in the background: `adb shell "/data/local/tmp/frida_server &"`

Once you've done this, you've done the hard part. All that's left is to install the client-side tools for Python by running

```
pip install frida
```

Once this is done, we're ready to start scripting!

### Dynamic Frida scripting with Python

Our goal is to write a Python script that 

- connects to the Frida server, 
- attaches it to our target app (InjuredAndroid), 
- hooks the decryption function, and
- prints the decrypted comparison string

We'll do the first two parts in Python (because it's easy), and the second two in Javascript (because that's the native language that Frida runs scripts in).

The Python script for the first two parts looks something like this:

```python
import frida

from time import sleep

def hook():
  device = frida.get_usb_device()  # connect to the Frida server running on the VM
  pid = device.spawn(["b3nac.injuredandroid"])  # start the InjuredAndroid app | note that this leaves the app in a paused state
  
  device.resume(pid)  # allow the app to execute as normal
  time.sleep(1)  # wait for the app to do setup | not doing this breaks the JavaScript injection
  session = device.attach(pid)  # attach our debugger to the app we spawned
  
  with open("flag_6_decrypt_hook.js") as f:
    script = session.create_script(f.read())  # read our JavaScript and use it to create a Frida script
    script.load()  # load the script into the target program
    
  input()  # pause and wait for our script to do its work
```

The injected JavaScript will do the heavy lifting. It will find the decryptor object (`b3nac.injuredandroid.k`) and override the decryption function
(`k.a()`) with a function that prints the decrypted string before returning as usual. This will look something like this:

```javascript
Java.perform(function hook_decrypt() {  // define a function to be injected into Java code
    console.log("[+] Hooking successful!");
    var decryptor_class = Java.use("b3nac.injuredandroid.k");  // find the class of interest
    var String = Java.use("java.lang.String");

    decryptor_class.a.overload("java.lang.String").implementation = function (input_string) { // override the decryption function
        console.log("[+] Reached hooked decrypt() function!");

        var original_arg = String.$new("k3FElEG9lnoWbOateGhj5pX6QsXRNJKh///8Jxi8KXW7iDpk2xRxhQ==");
        var decrypted_arg = this.a(original_arg);  // run the decryption function on the encrypted key
        console.log("[!] Decrypted key: " + decrypted_arg);  // print the decrypted key

        return this.a(input_string); // return the original function called on its original argument
    };
});

```

Note that we could have made our override return anything we want, which we could then easily match to our input. However, that's not a terribly realistic
exploit, since it requires us to already have code running on the device.

If all goes well, when we run the Python script, we should see a status message:

```
[+] Hooking successful!
```

We can then open the Flag 6 activity and enter a random flag. This will trigger our `decrypt()` hook:

```
[+] Hooking successful!
[+] Reached hooked decrypt() function!
[!] Decrypted key: {This_Isn't_Where_I_Parked_My_Car}
```

Bingo. Now we just have to enter this flag and...

![success_dynamic](https://user-images.githubusercontent.com/86139991/173958926-1aede79e-1aa2-4e9d-999b-04eb0e6b8b4e.PNG)

Awesome.

## The takeaway

So, what did we learn here?

In this challenge, we embarked on our first real flag hunt. We learned two methods to attack an app: static analysis, where we traced the code path
until we found a hardcoded encryption key and wrote our own decryption function, and dynamic analysis, where we attached Frida to the decryption function
and intercepted and printed the decrypted string.

Next time, we'll take on another hunt -- this time featuring databases.
